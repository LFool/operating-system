# 4. 操作系统的运行机制

![](../.gitbook/assets/os-yun-hang-ji-zhi-.svg)

## 1. 内核程序 v.s. 应用程序

普通程序员写的程序就是“**应用程序**”

微软、苹果有一帮人负责实现操作系统，他们写的是“**内核程序**”

由很多内核程序组成了“**操作系统内核**”，或简称“**内核（Kernel）**”

**内核**是操作系统最重要最核心的部分，也是**最接近硬件的部分**。甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核）

操作系统的功能未必都在内核中，如图形化用户界面GUI

## 2. 特权指令 v.s. 非特权指令

在 CPU 设计和生产时就划分了特权指令和非特权指令，因此 CPU 执行一条指令前就可以判断出其类型

**应用程序**只能使用“**非特权指令**”，如：加法指令、减法指令等

操作系统内核作为“管理者”，有时会让 CPU 执行一些“**特权指令**”，如：内存清零指令。这些指令影响重大，只允许“管理者” —— 即操作系统内核来使用

## 3. 内核态 v.s. 用户态

处于**内核态**时，说明此时正在**运行的是内核程序**，此时**可以执行特权指令**

处于**用户态**时，说明此时正在**运行的是应用程序**，此时**只能执行非特权指令**

CPU 中有一个寄存器叫**程序状态寄存器（PSW）**，其中有个二进制位，1 表示内核态，0 表示用户态

**别名：**内核态 = 核心态 = **管态**；用户态 = **目态**

## 4. 内核态 & 用户态切换

**内核态 —&gt; 用户态：**执行一条**特权指令 —— 修改 PSW** 的标志位为“用户态”，这个动作意味着操作系统将主动让出 CPU 使用权

**用户态 —&gt; 内核态：**由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回 CPU 的使用权

**触发中断信号：**除了非法使用特权指令之外，**但凡需要操作系统介入的地方**，都会触发中断信号

