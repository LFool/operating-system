# 2. 内存空间的分配与回收

## 1. 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。**系统区**常常位于内存的低地址部分，用于存放**操作系统**相关数据；**用户区**用于存放**用户进程**相关数据

内存中**只能有一道用户程序**，用户程序独占整个用户区空间

**优点：**实现简单；**无外部碎片**；可以采用覆盖技能扩充内存；不一定需要采取内存保护（因为只有一道用户程序）

**缺点：**只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

## 2. 固定分区分配

为了可以装入多道程序，且这些程序之间又不会互相干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

![](../.gitbook/assets/image%20%2845%29.png)

**分区大小相等：**缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**

**分区大小不等：**增加了灵活性，可以满足大小不同的进程需求，根据常在系统中运行的作业情况进行划分（划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构 —— **分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区的大小排列。每个表项包括：**分区的大小、起始状态、状态**（是否分配）

![](../.gitbook/assets/image%20%2839%29.png)

**优点：**实现简单、**无外部碎片**

**缺点：**

* 当用户程序太大，可能没有一个分区满足要求，不得不采用覆盖技术，会降低性能
* **会产生内部碎片**，内存利用率低

## 3. 动态分区分配

**动态分区分配（可变分区分配）：**不会预先分配分区，而是进程装入内存时，根据进程的大小动态地建立分区

### 3.1 记录内存的数据结构

**空闲分区表** and **空闲分区链**

![](../.gitbook/assets/image%20%2837%29.png)

### 3.2 空闲分区的选择

把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区中选择一个分区分配给该作业。

可参考后面介绍的[四种算法](2.-nei-cun-kong-jian-de-fen-pei-yu-hui-shou.md#34-shou-ci-kuo-ying-suan-fa-first-fit)

### 3.3 分区的分配 & 回收

#### 分配

* 情况一：当从空闲分区表中选择一个分区分配后，内存还有剩余，则修改表项
* 情况二：当从空闲分区表中选择一个分区分配后，刚刚好分配完，则删除该表项

#### 回收

* 情况一：回收区后面有一个相邻的空闲分区，则合并
* 情况二：回收区前面有一个相邻的空闲分区，则合并
* 情况三：回收区前后各有一个相邻的空闲分区，则三个合并为一个
* 情况四：回收区前后无相邻的空闲分区，则新增一个表项

**内部碎片：**分配给某些进程的内存区域中，有些部分没有用上

**外部碎片：**内存中某些空闲的分区由于太小而难以利用

如果内存中零碎的空间太多，导致无法满足内存较大的进程，可采用**拼凑技术**来解决外部碎片

**思考：**动态分区分配应该使用动态重定位装入（绝对装入地址改变，需要重新编译；静态装入，不支持移动）

### 3.4 首次适应算法（First Fit）

**算法思想：**每次都从低地址开始查找，找到第一个能满足大小的空闲分区

**实现方法：空闲分区以地址递增的次序开始排序**。每次分配内存时顺序查找**空闲分区链**（或空闲分区表），找到第一个满足大小的空闲分区

### 3.5 最佳适应算法（Best Fit）

**算法思想：**考虑大内存的进程有地可留，优先使用更小内存的空闲区

**实现方法：**空闲分区**按容量**递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区

**缺点：**每次都选小内存的分区进行分配，**会留下越来越多很小的、难以利用的内存块**。因此这种方法会产生很多外部碎片

### 3.6 最坏适应算法（Worst Fit）

又称**最大适应算法**（Largest Fit）

**算法思想：**避免留下越来越多的小内存块，优先使用更大内存的空闲块

**实现方法：**空闲分区按容量**递减**次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区

缺点：导致**更快是使用完大内存的空闲块**，使之后的大内存的进程无分区可用

### 3.7 邻近适应算法（Next Fit）

**算法思想：**首次适应算法，每次都从低地址开始遍历，导致低地址产生越来越多很小的空闲块。新来一个进程就重新从头开始遍历，会增加查找的开销。**邻近适应算法就是接着从上一次查找结束的位置开始检索**

**实现方法：**空闲分区按地址递增次序排列（可排成一个循环列表）。每次分配内存时**从上次查找结束的位置**开始查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区

**优点：**无论低地址还是高地址都有相同的概率被使用

### 3.8 对比

<table>
  <thead>
    <tr>
      <th style="text-align:center">&#x7B97;&#x6CD5;</th>
      <th style="text-align:center">&#x7B97;&#x6CD5;&#x601D;&#x60F3;</th>
      <th style="text-align:center">&#x5206;&#x533A;&#x6392;&#x5217;&#x987A;&#x5E8F;</th>
      <th style="text-align:center">&#x4F18;&#x70B9;</th>
      <th style="text-align:center">&#x7F3A;&#x70B9;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:center">&#x9996;&#x6B21;&#x9002;&#x5E94;</td>
      <td style="text-align:center">&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x627E;&#x5230;&#x7B2C;&#x4E00;&#x4E2A;&#x6EE1;&#x8DB3;&#x5927;&#x5C0F;&#x7684;&#x5185;&#x5B58;&#x7A7A;&#x95F2;&#x5206;&#x533A;</td>
      <td
      style="text-align:center">&#x6309;&#x5730;&#x5740;&#x9012;&#x589E;</td>
        <td style="text-align:center">
          <p>&#x7EFC;&#x5408;&#x6027;&#x80FD;&#x6700;&#x597D;</p>
          <p>&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5C0F;</p>
          <p>&#x56DE;&#x6536;&#x5206;&#x533A;&#x540E;&#x4E00;&#x822C;&#x4E0D;&#x9700;&#x8981;&#x5BF9;&#x7A7A;&#x95F2;&#x5206;&#x533A;&#x91CD;&#x65B0;&#x6392;&#x5E8F;</p>
        </td>
        <td style="text-align:center"></td>
    </tr>
    <tr>
      <td style="text-align:center">&#x6700;&#x4F73;&#x9002;&#x5E94;</td>
      <td style="text-align:center">
        <p>&#x4F18;&#x5148;&#x4F7F;&#x7528;&#x66F4;&#x5C0F;&#x7684;&#x5206;&#x533A;</p>
        <p>&#x4EE5;&#x4FDD;&#x7559;&#x66F4;&#x591A;&#x66F4;&#x5927;&#x7684;&#x5206;&#x533A;</p>
      </td>
      <td style="text-align:center">&#x6309;&#x5BB9;&#x91CF;&#x9012;&#x589E;</td>
      <td style="text-align:center">
        <p>&#x4F1A;&#x6709;&#x66F4;&#x591A;&#x66F4;&#x5927;&#x7684;&#x5185;&#x5B58;&#x7A7A;&#x95F2;&#x5757;&#x4FDD;&#x7559;</p>
        <p>&#x80FD;&#x6EE1;&#x8DB3;&#x66F4;&#x5927;&#x8FDB;&#x7A0B;&#x7684;&#x9700;&#x6C42;</p>
      </td>
      <td style="text-align:center">
        <p>&#x4F1A;&#x4EA7;&#x751F;&#x5F88;&#x591A;&#x5F88;&#x5C0F;</p>
        <p>&#x96BE;&#x4EE5;&#x5229;&#x7528;&#x7684;&#x788E;&#x7247;</p>
        <p>&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5927;&#xFF08;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x6392;&#x5E8F;&#xFF09;</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:center">&#x6700;&#x574F;&#x9002;&#x5E94;</td>
      <td style="text-align:center">
        <p>&#x4F18;&#x5148;&#x4F7F;&#x7528;&#x66F4;&#x5927;&#x7684;&#x5206;&#x533A;</p>
        <p>&#x4EE5;&#x9632;&#x6B62;&#x4EA7;&#x751F;&#x592A;&#x591A;&#x7684;&#x5916;&#x90E8;&#x788E;&#x7247;</p>
      </td>
      <td style="text-align:center">&#x6309;&#x5BB9;&#x91CF;&#x9012;&#x51CF;</td>
      <td style="text-align:center">&#x53EF;&#x4EE5;&#x51CF;&#x5C11;&#x96BE;&#x4EE5;&#x5229;&#x7528;&#x7684;&#x5C0F;&#x788E;&#x7247;&#xFF08;&#x5916;&#x90E8;&#x788E;&#x7247;&#xFF09;</td>
      <td
      style="text-align:center">
        <p>&#x5927;&#x5206;&#x533A;&#x5BB9;&#x6613;&#x88AB;&#x7528;&#x5B8C;</p>
        <p>&#x4E0D;&#x5229;&#x4E8E;&#x5927;&#x8FDB;&#x7A0B;</p>
        <p>&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5927;&#xFF08;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x6392;&#x5E8F;&#xFF09;</p>
        </td>
    </tr>
    <tr>
      <td style="text-align:center">&#x90BB;&#x8FD1;&#x9002;&#x5E94;</td>
      <td style="text-align:center">&#x6BCF;&#x6B21;&#x4ECE;&#x4E0A;&#x6B21;&#x7ED3;&#x675F;&#x7684;&#x4F4D;&#x7F6E;&#x5F00;&#x59CB;&#x67E5;&#x627E;</td>
      <td
      style="text-align:center">&#x6309;&#x5730;&#x5740;&#x9012;&#x589E;</td>
        <td style="text-align:center">&#x4E0D;&#x7528;&#x6BCF;&#x6B21;&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x68C0;&#x7D22;&#xFF0C;&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5C0F;</td>
        <td
        style="text-align:center">&#x4F1A;&#x662F;&#x9AD8;&#x5730;&#x5740;&#x7684;&#x5927;&#x5206;&#x533A;&#x4E5F;&#x88AB;&#x7528;&#x5B8C;</td>
    </tr>
  </tbody>
</table>

## 4. 基本分页存储管理

### 4.1 什么是分页管理

将内存分为一个个相等的分区，每个分区就是一个**页框（页框 = 页帧 = 内存块 = 物理块 = 物理页面）**

每个页框都有一个编号，即**页框号（页框号 = 页帧号 = 内存块号 = 物理块号 = 物理页号）**，页框号**从 0 开始**

将进程的逻辑地址空间分为与页框相等的一个个部分，每个部分称为一个**页**或**页面**。每个页面也有一个编号，即**页号**，页号也**从 0 开始**

操作系统**以页框为单位为各个进程分配**内存空间，进程的每个页面分别放入一个页框中（进程的**页面**与内存的**页框**有**一一对应**的关系）

### 4.2 页表

页表存放在物理内存中，页表起始地址和页表长度存在 PCB 中，记录了进程的每个页面在内存中的位置信息

![](../.gitbook/assets/image%20%2852%29.png)

**问题一：页表项占多少个字节**

Eg：假设某个系统物理内存大小为 4GB，页面大小为 4KB，则每个页表的页表项至少为多少字节？

内存块大小 = 页面大小 = 4 KB = $$2 ^{12} B$$ 

* 内存块数量 = $$2 ^{32} / 2 ^{12} = 2 ^{20}$$ 
* 内存块的范围是 $$0 \backsim 2 ^ {20} - 1$$ ，至少需要 20 bit 来表示
* 至少用 3B 来表示块号（3 \* 8 = 24 bit）
* 由于**页号是隐含的**，因此每个页表项占 3B，存储整个页表至少需要 3 \* \(n + 1\) B
  * 因为可以通过目标逻辑地址和页面大小推算出页号，故可以隐含
* 注意：通常我们设置的页表项最好可以使每个页面恰好装下整个页表项



**问题二：如何实现地址转换**

![](../.gitbook/assets/image%20%2840%29.png)

逻辑地址 A 对应的物理地址 = P 号页面在内存中的起始地址 + 页内偏移量 W

* 可以利用二进制的特点巧妙计算，即：物理地址 = （页框号，页内偏移量）-&gt; 二进制

### 4.3 基本地址变换机构

基本地址变换机构可以借助进程的页表实现将逻辑地址转换为物理地址

通常会在系统中设置一个**页表寄存器（PTR）**，存放**页表在内存中的起始地址 F** 和**页表长度 M**

进程未执行时，页表的始址 和 页表长度 **放在进程控制块（PCB）中**，当进程被调度是，操作系统内核会把它们放到页表寄存器中

![](../.gitbook/assets/image%20%2871%29.png)

假设页面大小为 L

1. 计算页号和页内偏移量：页号 $$p = A / L$$ ，页内偏移量 $$W = A \% L$$ （计算机可以根据逻辑地址的结构快速计算出）
2. 判断页号是否越界：查询页表寄存器中的页表长度 M，若 $$p \ge W$$ ，则越界；反之继续下一步
3. 查询页表，找到页号对应的页表项，确定页面存放的内存块号
4. $$E = b * L + W$$ 

### 4.4 快表

**快表**，又称**联想寄存器（TLB）**，是一种**访问速度比内存快很多**的**高速缓存，用来存放最近访问的页表项的副本**，可以加快地址变换的速度

![](../.gitbook/assets/image%20%2847%29.png)

引入快表后，**改变的地方：**

1. 会现在快表里查询，看看是否存在，如果不存在再去页表里查询
2. 在页表里查询到后，会把该表项存一份到快表中

![](../.gitbook/assets/image%20%2868%29.png)

**快表依据的是局部性原理**

* **空间局部性**
  * 一旦访问了某个存储单元，在不久后，其附近的存储单元也有可能被访问（因为很多数据在内存中都是**连续存放**的）
* **时间局部性**
  * 如果执行了程序中的某条指令，那么不久后很有可能再次执行到这条指令（因为程序中存在大量的**循环**）

### 4.5 两级页表

**单级页表存在的问题**

* 有时页表的长度可能会很大，同时页号隐含导致页表必须在内存中连续存放
* 根据局部性原理，很多时候，一段时间内只需要访问几个页面就可以正常运行，没必要让整个页表常驻内存

**两级页表的原理 & 地址结构**

![](../.gitbook/assets/image%20%2832%29.png)

1. 按照地址结构将逻辑地址拆分为三部分
2. **从 PCB 中读取页目录表始址**，再根据一级页号查页目录表，找到下一级页表在内存的存放位置
3. 根据二级页号查二级页表，找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址

在表项中**增加一个标志位**，即可实现部分页表存放在内存中

![](../.gitbook/assets/image%20%2848%29.png)

## 5. 基本分段存储管理

### 5.1 什么是分段管理

分页存储管理，每个页面的大小都是固定相同的，这样可能导致某些程序的逻辑被拆分，不利于信息的共享和保护

**分段：**按照程序的**自身逻辑**关系**划分为若干个段**，每个段都有一个段名，**每段从 0 开始编址**

内存分配规则：以段为单位进行分配，**每个段在内存中占据连续空间**，但**各段之间可以不相邻**

![](../.gitbook/assets/image%20%2825%29.png)

分段系统的逻辑地址结构：

![](../.gitbook/assets/image%20%2879%29.png)

### 5.2 段表

![](../.gitbook/assets/image%20%2872%29.png)

1. 每个段都对应一个段表项，其中记录了该段在内存中的起始位置（基址）和段的长度
2. 各个段表项的长度都是相同的，段号可以隐含，不占存储空间

### 5.3 地址变化

![](../.gitbook/assets/image%20%2842%29.png)

## 6. 段页式存储管理

### 6.1 段氏 & 页式 优缺点

![](../.gitbook/assets/image%20%2854%29.png)

### 6.2 段页式管理

先分段，再为每一段分页

![](../.gitbook/assets/image%20%2881%29.png)

![](../.gitbook/assets/image%20%2821%29.png)

![](../.gitbook/assets/image%20%2856%29.png)

每个段对应一个段表项，每个段表项由段号、**页表长度、页表存放块号（页表起始地址）**组成。每个**段表项长度相等，段号是隐含的**

每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的

### 6.3 地址变化

![](../.gitbook/assets/image%20%2833%29.png)



