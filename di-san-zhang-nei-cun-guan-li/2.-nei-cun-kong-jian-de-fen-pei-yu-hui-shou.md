# 2. 内存空间的分配与回收

## 1. 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。**系统区**常常位于内存的低地址部分，用于存放**操作系统**相关数据；**用户区**用于存放**用户进程**相关数据

内存中**只能有一道用户程序**，用户程序独占整个用户区空间

**优点：**实现简单；**无外部碎片**；可以采用覆盖技能扩充内存；不一定需要采取内存保护（因为只有一道用户程序）

**缺点：**只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

## 2. 固定分区分配

为了可以装入多道程序，且这些程序之间又不会互相干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

![](../.gitbook/assets/image%20%2837%29.png)

**分区大小相等：**缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**

**分区大小不等：**增加了灵活性，可以满足大小不同的进程需求，根据常在系统中运行的作业情况进行划分（划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构 —— **分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区的大小排列。每个表项包括：**分区的大小、起始状态、状态**（是否分配）

![](../.gitbook/assets/image%20%2834%29.png)

**优点：**实现简单、**无外部碎片**

**缺点：**

* 当用户程序太大，可能没有一个分区满足要求，不得不采用覆盖技术，会降低性能
* **会产生内部碎片**，内存利用率低

## 3. 动态分区分配

**动态分区分配（可变分区分配）：**不会预先分配分区，而是进程装入内存时，根据进程的大小动态地建立分区

### 3.1 记录内存的数据结构

**空闲分区表** and **空闲分区链**

![](../.gitbook/assets/image%20%2832%29.png)

### 3.2 空闲分区的选择

把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区中选择一个分区分配给该作业。

可参考后面介绍的四种算法

### 3.3 分区的分配 & 回收

#### 分配

* 情况一：当从空闲分区表中选择一个分区分配后，内存还有剩余，则修改表项
* 情况二：当从空闲分区表中选择一个分区分配后，刚刚好分配完，则删除该表项

#### 回收

* 情况一：回收区后面有一个相邻的空闲分区，则合并
* 情况二：回收区前面有一个相邻的空闲分区，则合并
* 情况三：回收区前后各有一个相邻的空闲分区，则三个合并为一个
* 情况四：回收区前后无相邻的空闲分区，则新增一个表项

## 4. 基本分页存储管理

## 5. 基本分段存储管理

## 6. 段页式存储管理



