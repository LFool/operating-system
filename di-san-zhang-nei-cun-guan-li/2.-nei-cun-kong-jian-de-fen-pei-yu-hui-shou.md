# 2. 内存空间的分配与回收

## 1. 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。**系统区**常常位于内存的低地址部分，用于存放**操作系统**相关数据；**用户区**用于存放**用户进程**相关数据

内存中**只能有一道用户程序**，用户程序独占整个用户区空间

**优点：**实现简单；**无外部碎片**；可以采用覆盖技能扩充内存；不一定需要采取内存保护（因为只有一道用户程序）

**缺点：**只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

## 2. 固定分区分配

为了可以装入多道程序，且这些程序之间又不会互相干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

![](../.gitbook/assets/image%20%2837%29.png)

**分区大小相等：**缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**

**分区大小不等：**增加了灵活性，可以满足大小不同的进程需求，根据常在系统中运行的作业情况进行划分（划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构 —— **分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区的大小排列。每个表项包括：**分区的大小、起始状态、状态**（是否分配）

![](../.gitbook/assets/image%20%2834%29.png)

**优点：**实现简单、**无外部碎片**

**缺点：**

* 当用户程序太大，可能没有一个分区满足要求，不得不采用覆盖技术，会降低性能
* **会产生内部碎片**，内存利用率低

## 3. 动态分区分配

**动态分区分配（可变分区分配）：**不会预先分配分区，而是进程装入内存时，根据进程的大小动态地建立分区

### 3.1 记录内存的数据结构

**空闲分区表** and **空闲分区链**

![](../.gitbook/assets/image%20%2832%29.png)

### 3.2 空闲分区的选择

把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区中选择一个分区分配给该作业。

可参考后面介绍的[四种算法](2.-nei-cun-kong-jian-de-fen-pei-yu-hui-shou.md#34-shou-ci-kuo-ying-suan-fa-first-fit)

### 3.3 分区的分配 & 回收

#### 分配

* 情况一：当从空闲分区表中选择一个分区分配后，内存还有剩余，则修改表项
* 情况二：当从空闲分区表中选择一个分区分配后，刚刚好分配完，则删除该表项

#### 回收

* 情况一：回收区后面有一个相邻的空闲分区，则合并
* 情况二：回收区前面有一个相邻的空闲分区，则合并
* 情况三：回收区前后各有一个相邻的空闲分区，则三个合并为一个
* 情况四：回收区前后无相邻的空闲分区，则新增一个表项

**内部碎片：**分配给某些进程的内存区域中，有些部分没有用上

**外部碎片：**内存中某些空闲的分区由于太小而难以利用

如果内存中零碎的空间太多，导致无法满足内存较大的进程，可采用**拼凑技术**来解决外部碎片

**思考：**动态分区分配应该使用动态重定位装入（绝对装入地址改变，需要重新编译；静态装入，不支持移动）

### 3.4 首次适应算法（First Fit）

**算法思想：**每次都从低地址开始查找，找到第一个能满足大小的空闲分区

**实现方法：空闲分区以地址递增的次序开始排序**。每次分配内存时顺序查找**空闲分区链**（或空闲分区表），找到第一个满足大小的空闲分区

### 3.5 最佳适应算法（Best Fit）

**算法思想：**考虑大内存的进程有地可留，优先使用更小内存的空闲区

**实现方法：**空闲分区**按容量**递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区

**缺点：**每次都选小内存的分区进行分配，**会留下越来越多很小的、难以利用的内存块**。因此这种方法会产生很多外部碎片

### 3.6 最坏适应算法（Worst Fit）

又称**最大适应算法**（Largest Fit）

**算法思想：**避免留下越来越多的小内存块，优先使用更大内存的空闲块

**实现方法：**空闲分区按容量**递减**次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区

缺点：导致**更快是使用完大内存的空闲块**，使之后的大内存的进程无分区可用

### 3.7 邻近适应算法（Next Fit）

**算法思想：**首次适应算法，每次都从低地址开始遍历，导致低地址产生越来越多很小的空闲块。新来一个进程就重新从头开始遍历，会增加查找的开销。**邻近适应算法就是接着从上一次查找结束的位置开始检索**

**实现方法：**空闲分区按地址递增次序排列（可排成一个循环列表）。每次分配内存时**从上次查找结束的位置**开始查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区

**优点：**无论低地址还是高地址都有相同的概率被使用

### 3.8 对比

<table>
  <thead>
    <tr>
      <th style="text-align:center">&#x7B97;&#x6CD5;</th>
      <th style="text-align:center">&#x7B97;&#x6CD5;&#x601D;&#x60F3;</th>
      <th style="text-align:center">&#x5206;&#x533A;&#x6392;&#x5217;&#x987A;&#x5E8F;</th>
      <th style="text-align:center">&#x4F18;&#x70B9;</th>
      <th style="text-align:center">&#x7F3A;&#x70B9;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:center">&#x9996;&#x6B21;&#x9002;&#x5E94;</td>
      <td style="text-align:center">&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x627E;&#x5230;&#x7B2C;&#x4E00;&#x4E2A;&#x6EE1;&#x8DB3;&#x5927;&#x5C0F;&#x7684;&#x5185;&#x5B58;&#x7A7A;&#x95F2;&#x5206;&#x533A;</td>
      <td
      style="text-align:center">&#x6309;&#x5730;&#x5740;&#x9012;&#x589E;</td>
        <td style="text-align:center">
          <p>&#x7EFC;&#x5408;&#x6027;&#x80FD;&#x6700;&#x597D;</p>
          <p>&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5C0F;</p>
          <p>&#x56DE;&#x6536;&#x5206;&#x533A;&#x540E;&#x4E00;&#x822C;&#x4E0D;&#x9700;&#x8981;&#x5BF9;&#x7A7A;&#x95F2;&#x5206;&#x533A;&#x91CD;&#x65B0;&#x6392;&#x5E8F;</p>
        </td>
        <td style="text-align:center"></td>
    </tr>
    <tr>
      <td style="text-align:center">&#x6700;&#x4F73;&#x9002;&#x5E94;</td>
      <td style="text-align:center">
        <p>&#x4F18;&#x5148;&#x4F7F;&#x7528;&#x66F4;&#x5C0F;&#x7684;&#x5206;&#x533A;</p>
        <p>&#x4EE5;&#x4FDD;&#x7559;&#x66F4;&#x591A;&#x66F4;&#x5927;&#x7684;&#x5206;&#x533A;</p>
      </td>
      <td style="text-align:center">&#x6309;&#x5BB9;&#x91CF;&#x9012;&#x589E;</td>
      <td style="text-align:center">
        <p>&#x4F1A;&#x6709;&#x66F4;&#x591A;&#x66F4;&#x5927;&#x7684;&#x5185;&#x5B58;&#x7A7A;&#x95F2;&#x5757;&#x4FDD;&#x7559;</p>
        <p>&#x80FD;&#x6EE1;&#x8DB3;&#x66F4;&#x5927;&#x8FDB;&#x7A0B;&#x7684;&#x9700;&#x6C42;</p>
      </td>
      <td style="text-align:center">
        <p>&#x4F1A;&#x4EA7;&#x751F;&#x5F88;&#x591A;&#x5F88;&#x5C0F;</p>
        <p>&#x96BE;&#x4EE5;&#x5229;&#x7528;&#x7684;&#x788E;&#x7247;</p>
        <p>&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5927;&#xFF08;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x6392;&#x5E8F;&#xFF09;</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:center">&#x6700;&#x574F;&#x9002;&#x5E94;</td>
      <td style="text-align:center">
        <p>&#x4F18;&#x5148;&#x4F7F;&#x7528;&#x66F4;&#x5927;&#x7684;&#x5206;&#x533A;</p>
        <p>&#x4EE5;&#x9632;&#x6B62;&#x4EA7;&#x751F;&#x592A;&#x591A;&#x7684;&#x5916;&#x90E8;&#x788E;&#x7247;</p>
      </td>
      <td style="text-align:center">&#x6309;&#x5BB9;&#x91CF;&#x9012;&#x51CF;</td>
      <td style="text-align:center">&#x53EF;&#x4EE5;&#x51CF;&#x5C11;&#x96BE;&#x4EE5;&#x5229;&#x7528;&#x7684;&#x5C0F;&#x788E;&#x7247;&#xFF08;&#x5916;&#x90E8;&#x788E;&#x7247;&#xFF09;</td>
      <td
      style="text-align:center">
        <p>&#x5927;&#x5206;&#x533A;&#x5BB9;&#x6613;&#x88AB;&#x7528;&#x5B8C;</p>
        <p>&#x4E0D;&#x5229;&#x4E8E;&#x5927;&#x8FDB;&#x7A0B;</p>
        <p>&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5927;&#xFF08;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x6392;&#x5E8F;&#xFF09;</p>
        </td>
    </tr>
    <tr>
      <td style="text-align:center">&#x90BB;&#x8FD1;&#x9002;&#x5E94;</td>
      <td style="text-align:center">&#x6BCF;&#x6B21;&#x4ECE;&#x4E0A;&#x6B21;&#x7ED3;&#x675F;&#x7684;&#x4F4D;&#x7F6E;&#x5F00;&#x59CB;&#x67E5;&#x627E;</td>
      <td
      style="text-align:center">&#x6309;&#x5730;&#x5740;&#x9012;&#x589E;</td>
        <td style="text-align:center">&#x4E0D;&#x7528;&#x6BCF;&#x6B21;&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x68C0;&#x7D22;&#xFF0C;&#x7B97;&#x6CD5;&#x5F00;&#x9500;&#x5C0F;</td>
        <td
        style="text-align:center">&#x4F1A;&#x662F;&#x9AD8;&#x5730;&#x5740;&#x7684;&#x5927;&#x5206;&#x533A;&#x4E5F;&#x88AB;&#x7528;&#x5B8C;</td>
    </tr>
  </tbody>
</table>

## 4. 基本分页存储管理

## 5. 基本分段存储管理

## 6. 段页式存储管理



