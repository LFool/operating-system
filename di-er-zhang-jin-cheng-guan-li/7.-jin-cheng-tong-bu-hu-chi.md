# 7. 进程同步 & 互斥

## 1. 什么是同步

我们知道进程具有**异步性**，即各并发执行的进程以不可预知的速度向前推进

但是很多时候，我们需要**多个进程以一定的顺序来执行**，如管道通信，只有写进程先执行后，读进程才可以执行，这就是进程同步需要处理的内容

**同步**亦称**直接制约关系**，它是指完成某种任务而建立的两个或多个进程因为需要在某些位置上**协调**它们的**工作次序**而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

## 2. 什么是互斥

并发需要共享的支持，各个并发的进程不可避免的需要共享一些系统资源（如：内存、打印机、摄像头）

**两种资源共享方式**

* **互斥共享方式：**系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程 访问该资源
* **同时共享方式：**系统中的某些资源，运行一个时间段内由多个进程“同时”对它们进行访问

**临界资源：**一个时间段内只允许一个进程使用的资源。如：物理设备（摄像头、打印机）都属于临界资源，此外还有许多变量、数据、内存缓冲区都属于临界资源

对临界资源的访问，必须**互斥**地进行。互斥亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源后，另一个进程才可以访问临界资源

对临界资源的互斥访问，可以逻辑上分为四个部分：

```c
do {
    /**
     * 进入区
     * 负责检查是否可以进入临界区
     * 若可以进入，则应设置正在访问临界资源的标志(上锁)
     * 以阻止其它进程同时访问临界区
     */
    entry section;
    /**
     * 临界区
     * 访问临界资源的代码
     */
    critical section;
    /**
     * 退出区
     * 负责解除正在访问临界资源的标志(解锁)
     */
    exit section;
    /**
     * 剩余区
     * 做其它处理
     */   
    remainder section;
} while (true)
```

实现对临界资源的**互斥访问**，同时**保证系统整体性能**，需要遵循**四个原则**：

1. **空闲让进：**临界区空闲时，可以允许一个请求进入临界区的进程进入临界区
2. **忙则等待：**当已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. **有限等待：**当请求访问的进程，应保证能在有限的时间内进入临界区（保存不会饥饿）
4. **让权等待：**当进程不能进入临界区，应立即释放处理机，防止进程忙等

## 3. 互斥的软件实现方法

### 3.1 单标志法

**算法思想：**两个进程在**访问临界区后**会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**

```c
int turn = 0; // turn 表示当前允许进入临界区的进程号(表示谦让)

// P0 进程
while (trun != 0);
critical section;
turn = 1;
remainder section;

// P1 进程
while (trun != 1);
critical section;
turn = 0;
remainder section;
```

**主要问题：**违背了**空闲让进**原则

* 当 turn = 0，P0 进程不需要访问临界区，P1 进程需要访问临界区，这样就会导致 P1 不能访问，但此时临界区时空闲的

### 3.2 双标志先检查法

**算法思想：**设置一个布尔类型数组 flag\[\]，数组中各个元素用来**标记各进程想进入临界区的意愿**，比如“flag\[0\] = true” 意味着 0 号进程 P0 现在想进入临界区。**每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区**，如果没有，则把自身对应的标志 flag\[i\] 设为 true，之后开始访问临界区

```c
bool flag[2]; // 表示进入临界区意愿的数组(表达意愿)
flag[0] = false; // P0 进程不想进入临界区
flag[1] = false; // P1 进程不想进入临界区

// P0 进程
while (flag[1]);   // 如果此时 P1 想进入临界区，P0 就一直循环等待 (检查)
flag[0] = true;    // 标记为 P0 进程想进入临界区 (上锁)
critical section;  // 访问临界区
flag[0] = false;   // 访问完临界区，修改标记为 P0 不想使用临界区
remainder section; //

// P1 进程
while (flag[0]);
flag[1] = true;
critical section;
flag[1] = false;
remainder section;
```

**主要问题：**违背了**忙则等待**原则

* 最开始，两个进程数组对应的值都为 false，两个进程同时访问临界区，由于都为 false，所以可以直接运行到 while 循环后
* **原因：检查** 和 **上锁** **不能一气呵成**

### 3.3 双标志后检查法

**算法思想：**在双标志先检查法的基础上进行了改进，**先上锁，后检查**

```c
bool flag[2]; // 表示进入临界区意愿的数组(表达意愿)
flag[0] = false; // P0 进程不想进入临界区
flag[1] = false; // P1 进程不想进入临界区

// P0 进程
flag[0] = true;    // 标记为 P0 进程想进入临界区 (上锁)
while (flag[1]);   // 如果此时 P1 想进入临界区，P0 就一直循环等待 (检查)
critical section;  // 访问临界区
flag[0] = false;   // 访问完临界区，修改标记为 P0 不想使用临界区
remainder section; //

// P1 进程
flag[1] = true;
while (flag[0]);
critical section;
flag[1] = false;
remainder section;
```

**主要问题：**违背了**空闲让进** & **有限等待**原则

* 可能两个进程同时上锁，导致谁都不能访问临界区，产生死等

### 3.4 Peterson 算法

**算法思想：**结合双标志法，单标志法的思想。如果双方都争着进入临界区，那可以让进程尝试**互相谦让，**即表达自己想进入临界区的意愿，但是先让别人访问

```c
bool flag[2]; // 表示进入临界区意愿的数组(表达意愿)
int turn = 0; // 表示当前允许进入临界区的进程号(表示谦让)
// P0 进程
flag[0] = true;
turn = 1;
while (flag[1] && turn == 1);
critical section;
flag[0] = false;
remainder section;

// P1 进程
flag[1] = true;
turn = 0;
while (flag[0] && turn == 0);
critical section;
flag[1] = false;
remainder section;
```

## 4. 互斥的硬件实现方法

### 4.1 中断屏蔽法

利用 “**开/关中断指令**” 实现（与原语实现的思想一样，即，一个进程访问临界区前先关中断，访问完成后开中断，这样就不可能发生两个同时访问临界区的情况）

![](../.gitbook/assets/image%20%2837%29.png)

**优点：**简单，高效

**缺点：**不适用于多处理机；只适用于操作系统内核程序，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意适用就很危险）

### 4.2 TestAndSet（TS 指令 / TSL 指令）

简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令

TSL 指令**是用硬件实现的**，执行过程中不允许被中断，只能一气呵成

```c
// 布尔型共享变量 lock 表示当前临界区是否被加锁
// true 表示加锁，false 表示未加锁
bool TestAndSet(bool *lock) {
    bool old;
    old = *lock;
    *lock = true;
    return old;
}

// 以下是使用 TSL 指令实现互斥的算法逻辑
while (TestAndSet(&lock));   // 上锁 并 检查
// 临界区代码段...
lock = false;                // 解锁
// 剩余区代码段...
```

**过程：**若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TSL 后 old 返回的值为 true，while 循环满足条件，会一直循环，直到当前访问临界区的进程在退出区进行解锁

**对比：**相比于软件实现方法，**TSL 指令把 上锁 和检查 操作用硬件的方式变成了一气呵成的原子操作**

**优点：**实现简单，无需像软件实现那样严格检查是否会有逻辑漏洞；适用于多处理机环境

**缺点：**不满足**让权等待**原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致**忙等**

### 4.3 Swap 指令（XCHG 指令）

也有叫 Exchange 指令，简称 XCHG 指令

Swap 指令**是用硬件实现的**，执行的过程不允许被中断，只能一气呵成

```c
// Swap 指令的作用是交换两个变量的值
Swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

// 以下是使用 TSL 指令实现互斥的算法逻辑
// lock 表示当前临界区是否被加锁
bool old = true；
while (old == true)
    Swap(&lock, &old);
// 临界区代码段...
lock = false;                // 解锁
// 剩余区代码段...
```

**过程：**逻辑上与 TSL 并无太大的区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区

**优点：**实现简单，无需像软件实现那样严格检查是否会有逻辑漏洞；适用于多处理机环境

**缺点：**不满足**让权等待**原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 Swap 指令，从而导致**忙等**

## 5. 信号量机制

用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进程操作，从而很方便的实现了进程互斥、进程同步

**信号量**其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来**表示系统中某种资源的数量**，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量

一对原语：**wait\(S\)**、**signal\(S\)**，简称为 **P**、**V** 操作

### 5.1 整型信号量

```c
int S = 1; // 初始化整型信号量 S，表示当前系统中可用的打印机资源数

void wait(int S) {   // wait 原语，相当于 进入区
    while (S <= 0);  // 如果资源数不够，就一直循环等待
    S = S - 1;       // 如果资源数够，则占用一个资源
}

void signal(int S) { // signal 原语，相当于 退出区
    S = S + 1;       // 使用完资源后，在退出区释放资源
}

// 进程 P0
wait(S);              // 进入区，申请资源
// 使用打印机资源...
signal(S);            // 退出区，释放资源

// 进程 P1
wait(S);
// 使用打印机资源...
signal(S);

// 进程 Pn
wait(S);
// 使用打印机资源...
signal(S);
```

**存在的问题：**不满足**让权等待**原则，会发生**忙等**

### 5.2 记录型信号量

整型信号量的缺陷是存在**忙等**问题，因此又提出了**记录型信号量**，即用记录型数据结构表示信号量

```c
/* 记录型信号量的定义 */
typedef struct {
    int value;          // 剩余资源数
    struct process *L;  // 等待队列
} semaphore;

/**
 * 某进程需要使用资源时，通过 wait 原语申请
 *
 * 对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源
 * 因此需要执行 S.value--，表示资源数减 1
 * 当 S.value < 0 时表示该类资源已经分配完毕
 * 因此进程应调用 block 原语进行自我阻塞（当前运行的进程从 运行态 -> 阻塞态）
 * 主动放弃处理机，并插入到该类资源的等待队列 S.L 中
 * 可见，该机制遵循了 让权等待 原则，不会出现 忙等 现象
 *
 */
void wait (semaphore S) {
    S.value--;
    while(s < 0) {
        // 如果剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态
        // 并把挂到信号量 S 的等待队列(即阻塞队列)中
        block(S.L);
    }
}

/**
 * 进程使用完资源后，通过 signal 原语释放
 *
 * 对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源
 * 因此需要执行 S.value++，表示资源数加 1
 * 若加 1 后仍是 S.value <= 0，表示依然有进程在等待该类资源
 * 因此调用 wakeup 原语唤醒等待队列中的第一个进程
 * （被唤醒进程从 阻塞态 -> 就绪态）
 *
 */
void signal(semaphore S) {
    s.value++;
    if (S.value <= 0) {
        // 释放资源后，若还有别的进程在等待这种资源
        // 则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
        wakeup(S.L);
    }
}
```

## 6. 用信号量机制实现进程同步、互斥、前驱关系

### 6.1 同步关系

**进程同步：**要让各并发进程按要求有序地推进

1. 分析什么地方需要实现 同步关系，即必须保证 一前一后执行的两个操作
2. 设置**同步信号量 S**，**初始值为 0**
3. 在 **前操作 之后执行 V\(S\)**
4. 在 **后操作 之前执行 P\(S\)**

```c
/**
 * 要求：代码4需要在代码1和代码2执行后才可以执行
 */
P1() {
    // 代码1
    // 代码2
    V(S);
    // 代码3
}
P2() {
    P(S);  //如果代码1和代码2没有执行完，就会主动请求阻塞
    // 代码4
    // 代码5
    // 代码6
}
```

### 6.2 互斥关系

1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区）
2. 设置**互斥信号量** mutex，**初值为 1**
3. 在进入区 P\(mutex\) —— **申请资源**
4. 在退出区 V\(mutex\) —— **释放资源**

注意：对于**不同的临界资源**需要**设置不同的互斥信号量**

![](../.gitbook/assets/image%20%2845%29.png)

```c
/* 信号量机制实现互斥 */
semaphore mutex = 1;  // 初始化信号量

P1() {
    // ...
    P(mutex);  // 使用临界资源前需要加锁
    // 临界区代码段...
    V(mutex);  // 使用临界资源后需要解锁
    // ...
}

P2() {
    // ...
    P(mutex);  // 使用临界资源前需要加锁
    // 临界区代码段...
    V(mutex);  // 使用临界资源后需要解锁
    // ...
}
```

### 6.3 前驱关系

1. 要**为每一对前驱关系各设置一个同步信号量**
2. 在 **前操作** 之**后**对相应的同步信号量**执行 V 操作**
3. 在 **后操作** 之**前**对相应的同步信号量**执行 P 操作**

![](../.gitbook/assets/image%20%2847%29.png)



